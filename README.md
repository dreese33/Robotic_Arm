# Robotic_Arm
Use of stepper motors and 3d printed parts to make a robotic arm from scratch. This project consists of a 2-dimensional simulator created using Matplotlib, and custom UI components (the ManualControlWheel was originally created in Swift as a Color Wheel - see https://github.com/dreese33/Psychedelic-Art-Generator. For this project it was re-implemented in python). 
Additionally, a StepperMotor library was implemented allowing users to run multiple stepper motors simultaneously in a single line of code. This library also accounts for different microstepping settings (I have tested various values of Stepper Motors using different microstepping values to minimize vibration of motors by setting it to a specific range of speeds that are optimal for that specific microstepping value, see https://www.njr.com/semicon/PDF/application_notes/Microstepping_APP_E.pdf to learn more about microstepping and vibration. Note: I did not write the pdf on this website, I used it as a source of information). 
The folder Ideas contains failed concepts that were attempts at developing a Simulator for the robot without using Matplotlib. StepperMotorMultithreaded was another failed attempt at running multiple stepper motors simultaneously because threading was very slow on the Raspberry Pi. Instead, the StepperMotor library runs motors simultaneously on a single thread by using an algorithm that sends a high signal to all of the motors, followed by a low signal after the delay time range is specified by the microstepping algorithm. Additionally, there are multiple functions in the StepperMotor library with the comment "Untested". The majority of these functions are attempting to run multiple stepper motors on a single thread with different microstepping values/speeds, allowing the robot to run much smoother. This either needs to be multithreaded or re-implemented since the algorithm itself slows down the motor speeds due to the delays between steps. I believe re-implementing these functions in C/C++ will allow for much faster processing and more predictable instruction execution times. Essentially, we need the execution time of the algorithm to run in less than 10 milliseconds per iteration, since that would be a negligable speed delay. This will be a future project. 
